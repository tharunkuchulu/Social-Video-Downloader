I understand that things might feel a bit overwhelming, but don’t worry—I’ll guide you step by step from the beginning to build your web application for downloading MP4 videos from X (Twitter) and Instagram using links from an Excel file. We’ll use **React with Vite (TypeScript)** for the frontend, **FastAPI** for the backend, and **MongoDB** (optional) for storing metadata. I’ll ensure we address the issues you’ve encountered (like missing dependencies and Excel file errors) and set up everything cleanly.

---

### Project Overview
- **Goal**: Build a web app where users can upload an Excel file containing video links (from X and Instagram), download the videos as MP4 files, and save them in a folder.
- **Tech Stack**:
  - **Frontend**: React with Vite (TypeScript) for a modern UI.
  - **Backend**: FastAPI (Python) to handle file uploads, process Excel data, and download videos.
  - **Database**: MongoDB (optional) to log download statuses.
  - **Tools**: `pandas` for Excel parsing, `yt-dlp` for downloading videos, `ffmpeg` for video processing.

---

### Step 1: Set Up Your Development Environment
Let’s start fresh by setting up your environment and ensuring all prerequisites are installed.

#### 1.1 Install Prerequisites
- **Node.js** (for Vite/React):
  - Download and install from [nodejs.org](https://nodejs.org/). Use the LTS version (e.g., 20.x as of March 2025).
  - Verify:
    ```bash
    node -v
    npm -v
    ```
- **Python 3.9+** (for FastAPI):
  - Download and install from [python.org](https://www.python.org/). Ensure you add Python to your PATH during installation.
  - Verify:
    ```bash
    python --version
    ```
- **MongoDB** (optional):
  - Install locally or use MongoDB Atlas (cloud) at [mongodb.com](https://www.mongodb.com/).
  - For local installation on Windows:
    - Download the installer from MongoDB’s website.
    - Run the installer and start the MongoDB service.
    - Verify:
      ```bash
      mongod --version
      ```
- **Git** (for version control):
  - Install from [git-scm.com](https://git-scm.com/).
  - Verify:
    ```bash
    git --version
    ```

#### 1.2 Create a New Project Directory
- Start fresh by creating a new directory for your project:
  ```bash
  mkdir video-downloader
  cd video-downloader
  ```

---

### Step 2: Set Up the Backend with FastAPI
We’ll create the backend first, which will handle the Excel file upload, read the video links, and download the videos.

#### 2.1 Create the Backend Directory
```bash
mkdir backend
cd backend
```

#### 2.2 Set Up a Python Virtual Environment
- Create and activate a virtual environment to keep dependencies isolated:
  ```bash
  python -m venv venv
  source venv/bin/activate  # On Windows: venv\Scripts\activate
  ```

#### 2.3 Install Backend Dependencies
- Install the required Python packages:
  ```bash
  pip install fastapi uvicorn pandas yt-dlp python-multipart pymongo openpyxl
  ```
- **Note**: We’re including `openpyxl` explicitly because `pandas` needs it to read `.xlsx` files, which caused an error in your previous setup.

#### 2.4 Install `ffmpeg`
- `yt-dlp` requires `ffmpeg` to merge video and audio streams into MP4 files. This was another issue you faced earlier.
- **On Windows**:
  1. Download `ffmpeg` from [ffmpeg.org](https://ffmpeg.org/download.html) or via Chocolatey:
     ```bash
     choco install ffmpeg
     ```
     - If you don’t have Chocolatey, download the executable, extract it, and add the `bin` folder (e.g., `C:\ffmpeg\bin`) to your system PATH.
  2. Verify:
     ```bash
     ffmpeg -version
     ```
- **On macOS**:
  ```bash
  brew install ffmpeg
  ```
- **On Linux**:
  ```bash
  sudo apt update
  sudo apt install ffmpeg  # For Ubuntu/Debian
  ```

#### 2.5 Create the FastAPI Backend (`main.py`)
Create a file named `main.py` in the `backend` directory with the following code:

```python
from fastapi import FastAPI, UploadFile, HTTPException
from fastapi.responses import JSONResponse
import pandas as pd
import yt_dlp
import os
from typing import List

app = FastAPI()

# Folder to save downloaded videos
DOWNLOAD_FOLDER = "downloads"

# Ensure the downloads folder exists
try:
    os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)
except Exception as e:
    raise Exception(f"Failed to create downloads folder: {str(e)}")

@app.post("/upload-excel/")
async def upload_excel(file: UploadFile):
    if not file.filename.endswith(".xlsx"):
        raise HTTPException(status_code=400, detail="Please upload an Excel file (.xlsx)")

    # Save uploaded file temporarily
    temp_file = f"temp_{file.filename}"
    try:
        with open(temp_file, "wb") as buffer:
            buffer.write(await file.read())
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save uploaded file: {str(e)}")

    # Read Excel file
    try:
        df = pd.read_excel(temp_file)
        print(f"Columns in Excel file: {df.columns.tolist()}")  # Debug: Print column names
        df.columns = df.columns.str.strip().str.lower()  # Normalize column names
        print(f"Normalized columns: {df.columns.tolist()}")  # Debug
        if "video_link" not in df.columns:
            raise ValueError("Excel file must contain a 'video_link' column")
        links = df["video_link"].tolist()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error reading Excel file: {str(e)}")
    finally:
        # Only attempt to delete the file if it exists
        if os.path.exists(temp_file):
            try:
                os.remove(temp_file)
            except Exception as e:
                print(f"Warning: Failed to delete temp file {temp_file}: {str(e)}")

    # Download videos
    try:
        results = await download_videos(links)
        return JSONResponse(content={"results": results})
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error downloading videos: {str(e)}")

async def download_videos(links: List[str]):
    ydl_opts = {
        "format": "bestvideo+bestaudio/best",  # Best quality MP4
        "outtmpl": f"{DOWNLOAD_FOLDER}/%(title)s.%(ext)s",  # Save to downloads folder
        "merge_output_format": "mp4",  # Ensure MP4 output
    }
    results = []
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        for link in links:
            try:
                ydl.download([link])
                results.append({"link": link, "status": "success"})
            except Exception as e:
                results.append({"link": link, "status": "failed", "error": str(e)})
    return results

@app.get("/test-download/")
async def test_download():
    links = ["https://www.youtube.com/watch?v=dQw4w9WgXcQ"]  # Test URL
    results = await download_videos(links)
    return JSONResponse(content={"results": results})

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

- **Notes**:
  - Added debug print statements to log the Excel column names, which will help us verify the `video_link` column.
  - Included a `/test-download/` endpoint to test downloading without uploading an Excel file.
  - Fixed the temporary file deletion issue by checking if the file exists before deleting.

#### 2.6 Test the Backend
1. **Run the FastAPI Server**:
   ```bash
   python main.py
   ```
   - You should see output like:
     ```
     INFO:     Started server process [1234]
     INFO:     Waiting for application startup.
     INFO:     Application startup complete.
     ```

2. **Test the `/test-download/` Endpoint**:
   - Open Postman or a browser.
   - Send a `GET` request to `http://127.0.0.1:8000/test-download/`.
   - **Expected Response**:
     ```json
     {
       "results": [
         {"link": "https://www.youtube.com/watch?v=dQw4w9WgXcQ", "status": "success"}
       ]
     }
     ```
   - Check the `downloads` folder in the `backend` directory for the downloaded video (e.g., `Rick Astley - Never Gonna Give You Up (Official Music Video).mp4`).
   - If you get an error about `ffmpeg`, ensure it’s installed (Step 2.4).

3. **Prepare an Excel File**:
   - Create a file named `links.xlsx` with the following content:
     ```
     video_link
     https://www.youtube.com/watch?v=dQw4w9WgXcQ
     ```
   - Save it as an `.xlsx` file using Excel or Google Sheets.

4. **Test the `/upload-excel/` Endpoint**:
   - In Postman, send a `POST` request to `http://127.0.0.1:8000/upload-excel/`.
   - Set the body to `form-data`, add a key named `file`, and upload `links.xlsx`.
   - **Expected Response**:
     ```json
     {
       "results": [
         {"link": "https://www.youtube.com/watch?v=dQw4w9WgXcQ", "status": "success"}
       ]
     }
     ```
   - Check the terminal logs for the debug output (e.g., `Columns in Excel file: ['video_link']`).

---

### Step 3: Set Up the Frontend with React (Vite + TypeScript)
Now that the backend is working, let’s set up the frontend.

#### 3.1 Create the Frontend Directory
```bash
cd ..  # Back to video-downloader root
npm create vite@latest frontend -- --template react-ts
cd frontend
npm install
```

#### 3.2 Install Additional Dependencies
- Install `axios` for making HTTP requests to the backend:
  ```bash
  npm install axios
  ```

#### 3.3 Create the React App (`src/App.tsx`)
Replace the contents of `src/App.tsx` with the following:

```tsx
import React, { useState } from "react";
import axios from "axios";

interface DownloadResult {
  link: string;
  status: string;
  error?: string;
}

const App: React.FC = () => {
  const [file, setFile] = useState<File | null>(null);
  const [results, setResults] = useState<DownloadResult[]>([]);
  const [loading, setLoading] = useState(false);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files) setFile(e.target.files[0]);
  };

  const handleUpload = async () => {
    if (!file) return;
    setLoading(true);
    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await axios.post("http://localhost:8000/upload-excel/", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });
      setResults(response.data.results);
    } catch (error) {
      console.error("Error uploading file:", error);
      setResults([{ link: "", status: "failed", "error": "Upload failed" }]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ padding: "20px" }}>
      <h1>Video Downloader</h1>
      <input type="file" accept=".xlsx" onChange={handleFileChange} />
      <button onClick={handleUpload} disabled={!file || loading}>
        {loading ? "Processing..." : "Upload & Download"}
      </button>
      {results.length > 0 && (
        <div>
          <h2>Results</h2>
          <ul>
            {results.map((result, index) => (
              <li key={index}>
                {result.link}: {result.status === "success" ? "Downloaded" : `Failed (${result.error})`}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

export default App;
```

#### 3.4 Update `src/main.tsx`
Ensure `src/main.tsx` looks like this:

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

#### 3.5 Run the Frontend
```bash
npm run dev
```
- Open `http://localhost:5173` (default Vite port) in your browser.
- You should see a simple UI with a file input and a button.

---

### Step 4: Test the Full Application
1. **Ensure the Backend is Running**:
   ```bash
   cd backend
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   python main.py
   ```
2. **Run the Frontend** (in a separate terminal):
   ```bash
   cd ../frontend
   npm run dev
   ```
3. **Test the App**:
   - Go to `http://localhost:5173`.
   - Upload the `links.xlsx` file you created earlier.
   - Click "Upload & Download".
   - You should see the results (e.g., "Downloaded" or "Failed") in the UI.
   - Check the `backend/downloads` folder for the downloaded videos.

---

### Step 5: Add MongoDB (Optional)
If you want to store download results in MongoDB:

#### 5.1 Update `main.py`
Add MongoDB integration to log the download results:

```python
from pymongo import MongoClient

# Connect to MongoDB
client = MongoClient("mongodb://localhost:27017/")
db = client["video_downloader"]
collection = db["downloads"]

# Update the upload_excel endpoint to save results to MongoDB
@app.post("/upload-excel/")
async def upload_excel(file: UploadFile):
    if not file.filename.endswith(".xlsx"):
        raise HTTPException(status_code=400, detail="Please upload an Excel file (.xlsx)")

    temp_file = f"temp_{file.filename}"
    try:
        with open(temp_file, "wb") as buffer:
            buffer.write(await file.read())
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save uploaded file: {str(e)}")

    try:
        df = pd.read_excel(temp_file)
        print(f"Columns in Excel file: {df.columns.tolist()}")
        df.columns = df.columns.str.strip().str.lower()
        print(f"Normalized columns: {df.columns.tolist()}")
        if "video_link" not in df.columns:
            raise ValueError("Excel file must contain a 'video_link' column")
        links = df["video_link"].tolist()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Error reading Excel file: {str(e)}")
    finally:
        if os.path.exists(temp_file):
            try:
                os.remove(temp_file)
            except Exception as e:
                print(f"Warning: Failed to delete temp file {temp_file}: {str(e)}")

    try:
        results = await download_videos(links)
        # Save results to MongoDB
        collection.insert_many(results)
        return JSONResponse(content={"results": results})
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error downloading videos: {str(e)}")

# Add an endpoint to retrieve download history
@app.get("/downloads/")
async def get_downloads():
    downloads = list(collection.find({}, {"_id": 0}))
    return JSONResponse(content={"downloads": downloads})
```

#### 5.2 Update the Frontend to Show Download History
Add a section in `App.tsx` to fetch and display the download history:

```tsx
import React, { useState, useEffect } from "react";
import axios from "axios";

interface DownloadResult {
  link: string;
  status: string;
  error?: string;
}

const App: React.FC = () => {
  const [file, setFile] = useState<File | null>(null);
  const [results, setResults] = useState<DownloadResult[]>([]);
  const [history, setHistory] = useState<DownloadResult[]>([]);
  const [loading, setLoading] = useState(false);

  // Fetch download history on component mount
  useEffect(() => {
    const fetchHistory = async () => {
      try {
        const response = await axios.get("http://localhost:8000/downloads/");
        setHistory(response.data.downloads);
      } catch (error) {
        console.error("Error fetching history:", error);
      }
    };
    fetchHistory();
  }, []);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files) setFile(e.target.files[0]);
  };

  const handleUpload = async () => {
    if (!file) return;
    setLoading(true);
    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await axios.post("http://localhost:8000/upload-excel/", formData, {
        headers: { "Content-Type": "multipart/form-data" },
      });
      setResults(response.data.results);
      // Refresh history after upload
      const historyResponse = await axios.get("http://localhost:8000/downloads/");
      setHistory(historyResponse.data.downloads);
    } catch (error) {
      console.error("Error uploading file:", error);
      setResults([{ link: "", status: "failed", error: "Upload failed" }]);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{ padding: "20px" }}>
      <h1>Video Downloader</h1>
      <input type="file" accept=".xlsx" onChange={handleFileChange} />
      <button onClick={handleUpload} disabled={!file || loading}>
        {loading ? "Processing..." : "Upload & Download"}
      </button>
      {results.length > 0 && (
        <div>
          <h2>Results</h2>
          <ul>
            {results.map((result, index) => (
              <li key={index}>
                {result.link}: {result.status === "success" ? "Downloaded" : `Failed (${result.error})`}
              </li>
            ))}
          </ul>
        </div>
      )}
      {history.length > 0 && (
        <div>
          <h2>Download History</h2>
          <ul>
            {history.map((entry, index) => (
              <li key={index}>
                {entry.link}: {entry.status === "success" ? "Downloaded" : `Failed (${entry.error})`}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

export default App;
```

---

### Step 6: Deploy (Optional)
Once everything is working locally, you can deploy your app:
- **Backend**:
  - Use a service like Heroku, Render, or AWS.
  - Install `gunicorn`:
    ```bash
    pip install gunicorn
    ```
  - Run with:
    ```bash
    gunicorn -w 4 main:app
    ```
- **Frontend**:
  - Build the React app:
    ```bash
    npm run build
    ```
  - Deploy to Netlify, Vercel, or GitHub Pages.
- **MongoDB**:
  - Use MongoDB Atlas for a cloud database.

---

### Step 7: Troubleshooting Tips
- **Excel File Issues**:
  - Ensure the column name is exactly `video_link` (case-sensitive, no spaces).
  - Check the terminal logs for the debug output (`Columns in Excel file`).
- **Download Failures**:
  - Some X or Instagram videos may require authentication or be private. Test with public YouTube videos first.
  - Ensure `ffmpeg` is installed and in your PATH.
- **CORS Issues**:
  - If the frontend can’t connect to the backend, add CORS support to `main.py`:
    ```python
    from fastapi.middleware.cors import CORSMiddleware

    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:5173"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    ```

---

### Conclusion
This guide starts from scratch and addresses the issues you faced (missing `openpyxl`, `ffmpeg`, and Excel column errors). By following these steps, you should have a working web application. Test each part (backend, frontend, and full workflow) as you go to catch any issues early.

Let me know if you encounter any specific errors, and I’ll help you debug!



